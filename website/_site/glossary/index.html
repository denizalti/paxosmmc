<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Glossary | Paxos Made Moderately Complex</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Glossary" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python." />
<meta property="og:description" content="Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python." />
<link rel="canonical" href="http://localhost:4000/glossary/" />
<meta property="og:url" content="http://localhost:4000/glossary/" />
<meta property="og:site_name" content="Paxos Made Moderately Complex" />
<script type="application/ld+json">
{"description":"Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.","@type":"WebPage","headline":"Glossary","url":"http://localhost:4000/glossary/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Paxos Made Moderately Complex" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Paxos Made Moderately Complex</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/how/">Paxos</a><a class="page-link" href="/paper/">Paper</a><a class="page-link" href="/code/">Code</a><a class="page-link" href="/glossary/">Glossary</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Glossary</h1>
  </header>

  <div class="post-content">
    <p><strong>Agreement:</strong> See <a href="#consensus">Consensus</a>.</p>

<p><a name="asynchronous"></a><strong>Asynchronous Environment:</strong> In an asynchronous environment there are no bounds on timing. In an asynchronous environment clocks run arbitrarily fast, network communication takes arbitrarily long, and <a href="#sm">state machines</a> take arbitrarily long to transition in response to an operation. Because there is no bound on timing for delivering and processing messages, it is impossible for other processes to know for certain that a process has failed or is being very very slow. The term “asynchronous” as used in the context of Paxos should not be confused with non-blocking operations on objects; they are often called asynchronous as well.</p>

<p><a name="availability"></a> <strong>Availability:</strong> A request that is sent to a machine in a distributed system may become idle if the machine is unavailable for any reason. In the worst case, the request can be delayed until the problem is fixed or the faulty machine is replaced by a replica. Availability is the ability of a distributed system to limit this latency as much as possible. For a distributed system to be available, it should also be <a href="#reliability">reliable</a>.</p>

<p><a name="bf"></a> <strong>Byzantine Failure:</strong> A <a href="#sm">state machine</a> has experienced a byzantine failure if it behaved in an arbitrary manner, which includes sending fake messages, not sending any messages, trying to disrupt the computation, corrupting their local state and processing requests incorrectly among other unspecified transitions. <a href="#paxos">Paxos</a> does not solve the <a href="#consensus">consensus</a> problem in the existence of byzantine failures.</p>

<p><a name="consensus"></a> <strong>Consensus:</strong> In the consensus problem, each process proposes some initial value, and processes that do not fail must reach an irrevocable decision on exactly one of the proposed values. The consensus problem captures an essential component of replication in distributed systems: the fact that replicas (processes) need to agree on the next state transition they handle, so that they can remain in identical states. <a href="#paxos">Paxos</a> solves the consensus problem in an asynchronous environment, where processes can crash. But Paxos (much like any other consensus protocol) is limited by the <a href="#flp">FLP Impossibility Result</a> in its ability to reach consensus in an asynchronous environment where processes can crash.</p>

<p><a name="consistency"></a> <strong>Consistency:</strong> Distributed systems replicate shared state to improve fault tolerance, data availability and performance. However, if the updates to this state are not carefully controlled, the state on different replicas might diverge over time creating inconsistency between replicas. In this case two clients that read the state from two different replicas might see two different states. To prevent this every distributed system supports a consistency model, i.e. employs a protocol that supports a consistency model. Different consistency models offer different consistency guarantees, but as long as the user follows the rules associated with a consistency model, the distributed system guarantees that the user will not observe any inconsistencies. The most intuitive type of consistency is strong consistency. A protocol supports strong consistency, if all state changes are seen by all distributed processes in the same order, sequentially. <a href="#paxos">Paxos</a> supports strong consistency.</p>

<p><a name="cf"></a> <strong>Crash Failure:</strong> A <a href="#sm">state machine</a> has experienced a crash failure if it will make no more transitions and thus its current state is fixed indefinitely. A crashed state machine does not make unspecified transitions. For machines that make unspecified transitions, see <a href="#bf">Byzantine failures</a>.</p>

<p><a name="dsm"></a> <strong>Deterministic State Machine:</strong> In a deterministic state machine for any state and operation, the transition enabled by the operation is unique and the output is a function only of the state and the operation. Logically, a deterministic state machine handles one operation at a time.</p>

<p><a name="fs"></a> <strong>Fail-Stop:</strong> A machine <a href="#cf">crash</a> is fail-stop if other machines can detect reliably that the process has crashed. In an <a href="#asynchronous">asynchronous</a> environment, one machine cannot tell whether another machine is slow or has crashed.</p>

<p><a name="ft"></a> <strong>Fault Tolerance:</strong> See <a href="#reliability">Reliability</a>.</p>

<p><a name="flp"></a> <strong>FLP Impossibility Result:</strong> ”Consensus problem is not solvable in an asynchronous system.” The result has been established by Fischer-Lynch-Paterson, hence the name FLP. The result states that there exists no deterministic algorithm that solves <a href="#consensus">consensus</a> in an <a href="#asynchronous">asynchronous</a> environment with reliable channels if one single process may <a href="#cf">crash</a>. This is due to the fact that in an asynchronous environment it is impossible to detect if a process has crashed or is very very slow. The basic idea behind the proof presented in the <a href="http://groups.csail.mit.edu/tds/papers/Lynch/pods83-flp.pdf">FLP paper</a> is to show circumstances under which the protocol remains forever indecisive.</p>

<p><a name="quorum"></a> <strong>Majority:</strong> See <a href="#quorum">Quorum</a>.</p>

<p><a name="paxos"></a><strong>Paxos:</strong> A <a href="#consensus">consensus</a> protocol for <a href="#smr">state machine replication</a> in an <a href="#asynchronous">asynchronous</a> environment that admits <a href="#cf">crash failures</a>.</p>

<p><a name="quorum"></a> <strong>Quorum:</strong> One way of achieving <a href="#consensus">consensus</a> in a distributed system is using voting. A quorum is the minimum number of votes that a replica has to obtain in order to be allowed to perform a state transition in a distributed system. There are two rules about determining quorums in a distributed system. First, any two quorums must intersect in at least one process. Second, at least one of the quorums (which ones is unknown) contains processes that never crash. This guarantees that if a replica received votes from a quorum there will always be at least one process that voted for the replica and is not crashed. A simple example of quorums is the following. There are <em>n</em> processes, of which fewer than <em>n/2</em> are allowed to crash. Quorums then are all sets that have <em>^[n+1]^⁄~2~</em> processes.</p>

<p><a name="reliability"></a><strong>Reliability:</strong> The ability of a distributed system to deliver its services even when one or several of its software of hardware components fail. Reliability is one of the main expected advantages of a distributed system: In a distributed setting a machine affected by a failure can always be replaced by another one, and not prevent the completion of a request. An immediate and obvious consequence is that reliability relies on redundancy of both the software components and the state, which is achieved by <a href="#replication">replication</a>.</p>

<p><a name="replication"></a> <strong>Replication:</strong> Maintaining multiple copies of state on replicated machines in a distributed system to achieve <a href="#ft">fault tolerance</a>. Replication increases fault tolerance, availability and performance but introduces <a href="#consistency">consistency</a> issues. When same state is copied on different servers it should be kept consistent to give the illusion of a single state.</p>

<p><a name="scalability"></a> <strong>Scalability:</strong> The ability of a system to continuously evolve in order to support a growing amount of tasks.</p>

<p><a name="sm"></a> <strong>State Machine:</strong> An abstract machine that consists of a collection of states, a collection of transitions between states, and a current state. A transition to a new current state happens in response to an issued operation and produces an output. Transitions from the current state to the same state are allowed, and are used to model read-only operations.</p>

<p><a name="smr"></a> <strong>State Machine Replication (SMR):</strong> A technique used in distributed systems to mask failures, and <a href="#cf">crash failures</a> in particular. A collection of <a href="#replication">replicas</a> of a <a href="#dsm">deterministic state machine</a> are created. The replicas are then provided with the same sequence of operations, so they go through the same sequence of state transitions and end up in the same state and produce the same sequence of outputs. This way consistency between replicas is achieved. It is assumed that at least one replica never crashes, but we do not know a priori which replica this is.</p>

<p><strong>Synchronous Environment:</strong> In a synchronous environment there are bounds on timing. In a synchronous system there is a bound on the transmission delay of messages, and a bound on the relative speed of processes. This allows accurate failure detection.</p>

<h2 id="references">References</h2>

<ul>
  <li>
    <p><a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos Wikipedia Page</a></p>
  </li>
  <li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed System. Commun. ACM 21, 7 (July 1978), 558–565.</a></li>
  <li><a href="https://www.cs.cornell.edu/fbs/publications/Fail_Stop.pdf">Richard D. Schlichting and Fred B. Schneider. 1983. Fail-stop Processors: An Approach to Designing Fault-tolerant Computing Systems. ACM Transactions on Computer Systems 1, 3 (Aug. 1983), 222–238.</a></li>
  <li><a href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">Fred B. Schneider. 1990. Implementing Fault-tolerant Services Using the State Machine Approach: A Tutorial. Comput. Surveys 22, 4 (Dec. 1990), 299–319.</a></li>
  <li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">Leslie Lamport. 1998. The Part-time Parliament. ACM Transactions on Computer Systems 16, 2 (May 1998), 133–169.</a>
<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf"></a></li>
  <li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf"></a><a href="http://research.microsoft.com/en-us/um/people/blampson/60-PaxosAlgorithm/Acrobat.pdf">Roberto De Prisco, Butler W. Lampson, and Nancy Lynch. 2000. Revisiting the PAXOS Algorithm. Theoretical Computer Science 243, 1-2 (July 2000), 35–91.</a></li>
  <li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">Leslie Lamport. 2001. Paxos Made Simple. ACM SIGACT News (Distributed Computing Column) 32, 4 (2001), 51–58.</a></li>
  <li><a href="http://research.microsoft.com/en-us/um/people/blampson/65-ABCDPaxos/Acrobat.pdf">Butler W. Lampson. 2001. The ABCD’s of Paxos. In Proceedings of the Twentieth Annual ACM Symposium on Principles of Distributed Computing (PODC ‘01). ACM, New York, NY, 13–14.</a></li>
  <li><a href="http://dl.acm.org/citation.cfm?id=1061989">Eli Gafni and Leslie Lamport. 2003. Disk Paxos. Distributed Computing 16, 1 (Feb. 2003), 1–20.</a></li>
  <li><a href="http://research.microsoft.com/pubs/64634/web-dsn-submission.pdf?q=cheap">Leslie Lamport and Mike Massa. 2004. Cheap Paxos. In Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN ‘04). IEEE Computer Society, Washington, DC, 307–315.</a></li>
  <li><a href="http://research.microsoft.com/pubs/64631/tr-2005-33.pdf">Leslie Lamport. 2005. Generalized Consensus and Paxos. Technical Report MSR-TR-2005-33. Microsoft Research, Mountain View, CA.</a></li>
  <li><a href="http://research.microsoft.com/pubs/64624/tr-2005-112.pdf">Leslie Lamport. 2006. Fast Paxos. Distributed Computing 19, 2 (October 2006), 79–103.</a></li>
  <li><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=101826">Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. 2008. Stoppable Paxos. Technical Report. Microsoft Research, Mountain View, CA.</a></li>
  <li><a href="http://research.microsoft.com/pubs/80907/podc09v6.pdf">Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. 2009. Vertical Paxos and Primary-Backup Replication. In Proceedings of the Twenty-Eighth ACM Symposium on Principles of Distributed Computing (PODC ‘09). ACM, New York, NY, 312–313.</a></li>
</ul>

<p>Note that this is an incomplete list. For more references, you can refer to the
<a href="/paper/">Paxos Made Moderately Complex</a> paper.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Paxos Made Moderately Complex</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Paxos Made Moderately Complex</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/denizalti"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">denizalti</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
