I"¯<ul>
  <li><a href="#why">WhyÂ is Paxos used in distributed systems?</a></li>
  <li><a href="#how">HowÂ does Paxos work?</a></li>
  <li><a href="#when">When does Paxos work and what are the limitations and practical issues of Paxos?</a></li>
</ul>

<h2 id="whyis-paxos-used-in-distributed-systems-">WhyÂ is Paxos used in distributed systems? <a name="why"></a></h2>

<p><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf"><strong>Paxos</strong></a>Â is a protocol for state machine replication in an asynchronous environment that admits crash failures.</p>

<p>A replicated state machine works by having multiple state machines, also called replicas, working in parallel, maintaining the same state. When the replicas receive requests from a client they update their state by executing the command in the request and reply to the client. This way, the state is automatically replicated by the replicas and in the event of a failure the state does not get lost, making the replicated state machine reliable.</p>

<p>It is easy for replicas to execute client commands in the same order and remain in sync if there is only one client or if multiple clients send their requests strictly sequentially as shown below:</p>

<p><img src="../static/rsm.gif" width="300" height="300" /></p>

<p>In this example replicas receive requests from clients in the same order, execute the commands in the same order and respond to the clients, in effect staying in sync. For simplicity, it is assumed that a client can ignore duplicated responses.</p>

<p>But if multiple clients send requests to replicas in parallel, then different replicas might receive these requests in different orders and execute the commands in different orders, causing their local states to diverge from one another over time.</p>

<p>To prevent replicas from diverging in the presence of multiple clients sending requests in parallel, the order in which the client commands will be executed by replicas should be decided. We show this case below:</p>

<p><img src="../static/consensus.gif" width="420" height="300" /></p>

<p>To decide the order in which the client commands will be executed the replicas can be thought of as having a sequence of slots that need to be filled with commands that make up the inputs to the state machine they maintain. In the example this sequence is shown as a table. Each slot is indexed by a slot number, starting from 1. Replicas receive requests from clients and assign them to specific slots, creating a sequence of commands. In the face of concurrently operating clients, different replicas may end up proposing different commands for the same slot. To avoid inconsistency, a consensus protocol chooses a single command from the proposals for every slot. In Paxos the subprotocol that implements consensus is called theÂ <strong>multi-decree Synod</strong>Â protocol, or justÂ <strong>Synod</strong>Â protocol for short. A replica awaits the decision before actually updating its sequence of commands in the table, executing the next command and computing a response to send back to the client that issued the request.</p>

<p>Essentially, the replicated state machine uses Paxos as an ordering entity which uses consensus to agree on which client command gets assigned to which slot. One has to make sure that the ordering entity itself is also reliable, that it can tolerate failures (at mostÂ <em>f</em>) just like the replicated state machine. To achieve reliability, Paxos is run by multiple specialized processes in a distributed fashion. This is not trivial because up toÂ <em>f</em>Â processes running Paxos might fail at any time and, because there is no bound on timing for delivering and processing messages, it is impossible for other processes to know for certain that the process has failed.</p>

<h2 id="how-does-paxos-work-">How does Paxos work? <a name="how"></a></h2>
<p>Paxos uses servers that have different roles in the execution of the protocol.
The execution logic, and the insights behind the correctness of the protocol
is covered here for each role.</p>

<ul>
  <li><strong><a href="#replicas">How do Replicas work?</a></strong></li>
  <li><strong><a href="#acceptors">How do Acceptors work?</a></strong></li>
  <li><strong><a href="#leaders">How do Leaders work?</a></strong></li>
</ul>

<h3 id="how-do-replicas-work">How do Replicas work?<a name="replicas"></a></h3>

<p>When a client Îº wants to execute a command c=âŸ¨Îº,cid,opâŸ©, its stub routine broadcasts a âŸ¨request,câŸ© message to all replicas and waits for a âŸ¨response,cid,resultâŸ© message from one of the replicas.</p>

<p>The replicas can be thought of as having a sequence of slots. that need to be filled with commands that make up the inputs to the state machine. Each slot is indexed by a slot number. Replicas receive requests from clients and assign them to specific slots, creating a sequence of commands. A replica, on receipt of a âŸ¨request,câŸ© message, proposes command c for its lowest unused slot. We call the pair (s,c) a proposal for slot s.</p>

<p>Replicas use the Synod protocol to choose a single command for each slot from the proposals they make. For each slot, the Synod protocol runs between a set of processes called the configuration of the slot. The configuration contains the leaders and the acceptors, but not the replicas. Leaders receive proposed commands from replicas and are responsible for choosing a single command for the slot. Thus, in order to tolerate  f crash failures, Paxos needs at least f+1 leaders, always leaving at least 1 leader to order the commands proposed by replicas. A replica awaits the decision before actually updating its state and computing a response to send back to the client that issued the request.</p>

<p>Usually, the configuration for consecutive slots is the same. Sometimes, such as when a process in the configuration is suspected of having crashed, it is useful to be able to change the configuration. Paxos supports reconfiguration: a client can propose a special reconfiguration command, which is decided in a slot just like any other command. However, if s is the index of the slot in which a new configuration is decided, it does not take effect until slot s+ğš†ğ™¸ğ™½ğ™³ğ™¾ğš†. This allows up to ğš†ğ™¸ğ™½ğ™³ğ™¾ğš† slots to have proposals pendingâ€”the configuration of later slots may change. It is always possible to add new replicasâ€”this does not require a reconfiguration of the leaders and acceptors.</p>

<h2 id="replica-state">Replica State</h2>
<p>Each replica Ï maintains seven variables:</p>

<p>Ï.state, the replicaâ€™s copy of the application state, which we will treat as opaque. All replicas start with the same initial application state.
Ï.slot_in, the index of the next slot in which the replica has not yet proposed any command. Initially 1.
Ï.slot_out, the index of the next slot for which it needs to learn a decision before it can update its copy of the application state. Equivalent to the stateâ€™s version number (i.e., number of updates), and initially 1.
Ï.requests, an initially empty set of requests that the replica has received and are not yet proposed or decided.
Ï.proposals, an initially empty set of proposals that are currently outstanding.
Ï.decisions, another set of proposals that are known to have been decided (also initially empty).
Ï.leaders, the set of leaders in the current configuration. The leaders of the initial configuration are passed as an argument to the replica.
Replica Invariants
For correctness following invariants hold over the collected variables of replicas both before and after state transitions:</p>

<ul>
  <li>R1: There are no two different commands decided for the same slot:    âˆ€s,Ï1,Ï2,c1,c2:âŸ¨s,c1âŸ©âˆˆÏ1.decisions âˆ§ âŸ¨s,c2âŸ©âˆˆÏ2.decisionsâ‡’c1=c2</li>
  <li>R2: All commands up to slot_out are in the set of decisions:    âˆ€Ï,s:1â‰¤s&lt;Ï.slot_outâ‡’âˆƒc:âŸ¨s,câŸ©âˆˆÏ.decisions</li>
  <li>R3: For all replicas Ï, Ï.state is the result of applying the commands âŸ¨s,csâŸ©âˆˆÏ.decisions to initial_state for all s up to slot_out, in order of slot number;</li>
  <li>R4: For each Ï, the variable Ï.slot_out cannot decrease over time.</li>
  <li>R5: A replica proposes commands only for slots it knows the configuration for:    âˆ€Ï:Ï.slot_in&lt;Ï.slot_out+ğš†ğ™¸ğ™½ğ™³ğ™¾ğš†.</li>
</ul>

<p>To understand the significance of such invariants, it is useful to consider what would happen if one of the invariants would not hold. If R1 would not hold, replicas could diverge, ending up in different states even if they have applied the same number of commands. Also, without R1, the same replica could decide multiple different commands for the same slot, because Ï1 and Ï2 could be the same process. Thus, the application state of that replica would be ambiguous.</p>

<p>Invariants R2-R4 ensure that, for each replica Ï, the sequence of the first Ï.slot_out commands is recorded and fixed. If any of these invariants were invalidated, a replica could change its history and end up with a different application state. The invariants do not imply that the slots have to be decided in order; they only imply that decided commands have to be applied to the application state in order and that there is no way to roll back.</p>

<p>Invariant R5 guarantees that replicas do not propose commands for slots that have an uncertain configuration. Because a configuration for slot s takes effect at slot s+ğš†ğ™¸ğ™½ğ™³ğ™¾ğš† and all decisions up to slot_inâˆ’1 are known, configurations up to slot Ï.slot_in+ğš†ğ™¸ğ™½ğ™³ğ™¾ğš†âˆ’1 are known.</p>

<h2 id="replica-operational-description">Replica Operational Description</h2>
<p>Below you can find the pseudo-code for a Replica:</p>

<pre><code>
ğš™ğš›ğš˜ğšŒğšğšœğšœ Replica(leaders,initial_state)
  ğšŸğšŠğš› state:=initial_state,slot_in:=1,slot_out:=1;
  ğšŸğšŠğš› requests:=âˆ…,proposals:=âˆ…,decisions:=âˆ…;

  ğšğšğš—ğšŒğšğš’ğš˜ğš— propose()
    ğš ğš‘ğš’ğš•ğš slot_in&lt;slot_out+ğš†ğ™¸ğ™½ğ™³ğ™¾ğš†âˆ§âˆƒc:câˆˆrequests ğšğš˜
      ğš’ğš âˆƒop:âŸ¨slot_inâˆ’ğš†ğ™¸ğ™½ğ™³ğ™¾ğš†,âŸ¨â‹…,â‹…,opâŸ©âŸ©âˆˆdecisionsâˆ§isreconfig(op) ğšğš‘ğšğš—
        leaders:=op.leaders;
      ğšğš—ğš ğš’ğš
      ğš’ğš âˆ„câ€²:âŸ¨slot_in,câ€²âŸ©âˆˆdecisions ğšğš‘ğšğš—
        requests:=requestsâˆ–{c};
        proposals:=proposalsâˆª{âŸ¨slot_in,câŸ©};
        âˆ€Î»âˆˆleaders:send(Î»,âŸ¨propose,slot_in,câŸ©);
      ğšğš—ğš ğš’ğš
      slot_in:=slot_in+1;
    ğšğš—ğš ğš ğš‘ğš’ğš•ğš
  ğšğš—ğš ğšğšğš—ğšŒğšğš’ğš˜ğš—

  ğšğšğš—ğšŒğšğš’ğš˜ğš— perform(âŸ¨Îº,cid,opâŸ©)
    ğš’ğš (âˆƒs:s&lt;slot_outâˆ§âŸ¨s,âŸ¨Îº,cid,opâŸ©âŸ©âˆˆdecisions) âˆ¨isreconfig(op) ğšğš‘ğšğš—
      slot_out:=slot_out+1;
    ğšğš•ğšœğš
      âŸ¨next,resultâŸ©:=op(state);
      ğšŠğšğš˜ğš–ğš’ğšŒ
        state:=next; slot_out:=slot_out+1;
      ğšğš—ğš ğšŠğšğš˜ğš–ğš’ğšŒ
      send(Îº,âŸ¨response,cid,resultâŸ©);
    ğšğš—ğš ğš’ğš
  ğšğš—ğš ğšğšğš—ğšŒğšğš’ğš˜ğš—

  ğšğš˜ğš› ğšğšŸğšğš›
    ğšœğš ğš’ğšğšŒğš‘ receive()
      ğšŒğšŠğšœğš âŸ¨request,câŸ©:
        requests:=requestsâˆª{c};
      ğšğš—ğš ğšŒğšŠğšœğš
      ğšŒğšŠğšœğš âŸ¨decision,s,câŸ©:
        decisions:=decisionsâˆª{âŸ¨s,câŸ©};
        ğš ğš‘ğš’ğš•ğš âˆƒcâ€²:âŸ¨slot_out,câ€²âŸ©âˆˆdecisions ğšğš˜
          ğš’ğš âˆƒcâ€³:âŸ¨slot_out,câ€³âŸ©âˆˆproposals ğšğš‘ğšğš—
            proposals:=proposalsâˆ–{âŸ¨slot_out,câ€³âŸ©};
            ğš’ğš câ€³â‰ câ€² ğšğš‘ğšğš—
              requests:=requestsâˆª{câ€³};
            ğšğš—ğš ğš’ğš
          ğšğš—ğš ğš’ğš
          perform(câ€²);
        ğšğš—ğš ğš ğš‘ğš’ğš•ğš
      ğšğš—ğš ğšŒğšŠğšœğš
    ğšğš—ğš ğšœğš ğš’ğšğšŒğš‘
    propose();
  ğšğš—ğš ğšğš˜ğš›
ğšğš—ğš ğš™ğš›ğš˜ğšŒğšğšœğšœ
</code></pre>

<p>A replica runs in an infinite loop, receiving messages. Replicas receive two kinds of messages: requests and decisions. When it receives a request for command c from a client, the replica adds the request to set requests. Next, the replica invokes the function propose().</p>

<p>Function propose() tries to transfer requests from the set requests to proposals. It uses slot_in to look for unused slots within the window of slots with known configurations. For each such slot s, it first checks if the configuration for s is different from the prior slot by checking if the decision in slot sâˆ’ğš†ğ™¸ğ™½ğ™³ğ™¾ğš† is a reconfiguration command. If so, the function updates the set of leaders for slot s. Then the function removes a request r from requests and adds proposal (s,r) to the set proposals. Finally, it sends a âŸ¨propose,s,câŸ© message to all leaders in the configuration of slot s.</p>

<p>Decisions may arrive out-of-order and multiple times. For each decision message, the replica adds the decision to the set decisions. Then, in a loop, it considers which decisions are ready for execution before trying to receive more messages. If there is a decision câ€² corresponding to the current slot_out, the replica first checks to see if it has proposed a command câ€³ for that slot. If so, the replica removes âŸ¨slot_out,câ€³âŸ© from the set proposals. If câ€³â‰ câ€², that is, the replica proposed a different command for that slot, the replica returns câ€³ to set requests so câ€³ is proposed again at a later time. Next, the replica invokes perform(câ€²).</p>

<p>The function perform() is invoked with the same sequence of commands at all replicas. First, it checks to see if it has already performed the command. Different replicas may end up proposing the same command for different slots, and thus the same command may be decided multiple times. The corresponding operation is evaluated only if the command is new and it is not a reconfiguration request. If so, perform() applies the requested operation to the application state. In either case, the function increments slot_out.</p>

<h2 id="maintenance-of-replica-invariants">Maintenance of Replica Invariants</h2>
<p>Note that decisions is â€˜â€˜append-onlyâ€™â€™ in that there is no code that removes entries from this set. Doing so makes it easier to formulate invariants and reason about the correctness of the code. We will discuss correctness-preserving ways of removing entries that are no longer useful in the context of optimizations later.</p>

<p>It is clear that the code enforces Invariant R4. The variables state and slot_out are updated atomically in order to ensure that Invariant R3 holds, although in practice it is not actually necessary to perform these updates atomically, as the intermediate state is not externally visible. Since slot_out is only advanced if the corresponding decision is in decisions, it is clear that Invariant R2 holds. A command is proposed for a slot only if that slot is within the current ğš†ğ™¸ğ™½ğ™³ğ™¾ğš†, and since replicas execute reconfiguration commands after a ğš†ğ™¸ğ™½ğ™³ğ™¾ğš† of operations it is ensured that Invariant R5 holds.</p>

<p>The real difficulty lies in enforcing Invariant R1. It requires that the set of replicas agree on the order of commands. For each slot, the Paxos protocol chooses a command from among a collection of commands proposed by clients. This is called consensus, and in Paxos the subprotocol that implements consensus is called the â€˜â€˜multi-decree Synodâ€™â€™ protocol, or just Synod protocol for short.</p>

<h3 id="how-do-acceptors-work">How do Acceptors work?<a name="acceptors"></a></h3>

<p>In the Synod protocol, there is an unbounded collection of ballots. Ballots are the key to liveness properties in Paxos. Each ballot has a unique leader. A leader can be working on arbitrarily many ballots, although it will be predominantly working on one at a time. A leader process has a unique identifier called the leader identifier. Each ballot has a unique identifier, called its ballot number. Ballot numbers are totally ordered, that is, for any two different ballot numbers, one is before or after the other. Do not confuse ballot numbers and slot numbers; they are orthogonal concepts. One ballot can be used to decide multiple slots, and one slot may be targeted by multiple ballots.</p>

<p>In this description, we will have ballot numbers be lexicographically ordered pairs of an integer and its leader identifier (consequently, leader identifiers need to be totally ordered as well). This way, given a ballot number, it is trivial to see who the leader of the ballot is. We will use one special ballot number âŠ¥ that is ordered before any normal ballot number, but does not correspond to any ballot.</p>

<p>During the Synod protocol leaders send messages to acceptors, so one can think of acceptors as servers, and leaders as their clients. Acceptors maintain the fault tolerant memory of Paxos, preventing conflicting decisions from being made. Acceptors use a voting protocol, allowing a unanimous majority of acceptors to decide without needing input from the remaining acceptors. Thus, in order to tolerate f crash failures, Paxos needs at least 2f+1 acceptors, always leaving at least f+1 acceptors to maintain the fault tolerant memory. Keep in mind that acceptors are not replicas of one another, because they get different sequences of input from leaders.</p>

<p>The figure below illustrates the communication patterns between the various types of processes in a setting where f=2.</p>

<center>
<img src="../static/communication.png" height="300" />
</center>

<h2 id="acceptor-state">Acceptor State</h2>
<p>An acceptor is quite simple, as it is passive and only sends messages in response to requests. Its state consists of two variables. Let a pvalue be a triple consisting of a ballot number, a slot number, and a command. If Î± is the identifier of an acceptor, then the acceptorâ€™s state is described by</p>

<ul>
  <li>Î±.ballot_num: a ballot number, initially âŠ¥.</li>
  <li>Î±.accepted: a set of pvalues, initially empty.</li>
</ul>

<p>Under the direction of messages sent by leaders, the state of an acceptor can change. Let p=âŸ¨b,s,câŸ© be a pvalue consisting of a ballot number b, a slot number s, and a command c. When an acceptor Î± adds p to Î±.accepted, we say that Î± accepts p. An acceptor may accept the same pvalue multiple times. When Î± sets its ballot number to b for the first time, we say that Î± adopts b.</p>

<h2 id="acceptor-invariants">Acceptor Invariants</h2>
<p>Knowing these invariants is an invaluable help to understanding the Synod protocol:</p>

<ul>
  <li>A1: An acceptor can only adopt strictly increasing ballot numbers.</li>
  <li>A2: An acceptor Î± can only accept âŸ¨b,s,câŸ© if b=Î±.ballot_num;</li>
  <li>A3: Acceptor Î± cannot remove pvalues from Î±.accepted (we will modify this impractical restriction later).</li>
  <li>A4: Suppose Î± and Î±â€² are acceptors, with âŸ¨b,s,câŸ©âˆˆÎ±.accepted and âŸ¨b,s,câ€²âŸ©âˆˆÎ±â€².accepted. Then c=câ€². Informally, given a particular ballot number and slot number, there can be at most one proposed command under consideration by the set of acceptors.</li>
  <li>A5: Suppose that for each Î± among a majority of acceptors, âŸ¨b,s,câŸ©âˆˆÎ±.accepted. If bâ€²&gt;b and âŸ¨bâ€²,s,câ€²âŸ©âˆˆÎ±â€².accepted, then c=câ€².</li>
</ul>

<p>It is important to realize that Invariant A5 works in two ways. In one way, if all acceptors in a majority have accepted a particular pvalue âŸ¨b,s,câŸ©, then any pvalue for a later ballot will contain the same command c for slot s. In the other way, suppose some acceptor accepts âŸ¨bâ€²,s,câ€²âŸ©. At a later time, if any majority of acceptors accepts pvalue âŸ¨b,s,câŸ© on an earlier ballot b&lt;bâ€², then c=câ€².</p>

<h2 id="acceptor-operational-description">Acceptor Operational Description</h2>
<p>Below you can find the pseudo-code for an Acceptor:</p>

<pre><code>
ğš™ğš›ğš˜ğšŒğšğšœğšœ Acceptor()
  ğšŸğšŠğš› ballot_num:=âŠ¥,accepted:=âˆ…;

  ğšğš˜ğš› ğšğšŸğšğš›
    ğšœğš ğš’ğšğšŒğš‘ receive()
      ğšŒğšŠğšœğš âŸ¨p1a,Î»,bâŸ©:
        ğš’ğš b&gt;ballot_num ğšğš‘ğšğš—
          ballot_num:=b;
        ğšğš—ğš ğš’ğš
        send(Î»,âŸ¨p1b,self(),ballot_num,acceptedâŸ©);
      ğšğš—ğš ğšŒğšŠğšœğš
      ğšŒğšŠğšœğš âŸ¨p2a,Î»,âŸ¨b,s,câŸ©âŸ©:
        ğš’ğš b=ballot_num ğšğš‘ğšğš—
          accepted:=acceptedâˆª{âŸ¨b,s,câŸ©};
        ğšğš—ğš ğš’ğš
        send(Î»,âŸ¨p2b,self(),ballot_numâŸ©);
      ğšğš—ğš ğšŒğšŠğšœğš
    ğšğš—ğš ğšœğš ğš’ğšğšŒğš‘
  ğšğš—ğš ğšğš˜ğš›
ğšğš—ğš ğš™ğš›ğš˜ğšŒğšğšœğšœ
</code></pre>

<p>The Acceptor runs in an infinite loop, receiving two kinds of request messages from leaders (note the use of pattern matching):</p>

<ul>
  <li>âŸ¨p1a,Î»,bâŸ©: Upon receiving a â€˜â€˜phase 1aâ€™â€™ request message from a leader with identifier Î», for a ballot number b, an acceptor makes the following transition. First, the acceptor adopts b if and only if it exceeds its current ballot number. Then it returns to Î» a â€˜â€˜phase 1bâ€™â€™ response message containing its current ballot number and all pvalues accepted thus far by the acceptor.</li>
  <li>âŸ¨p2a,Î»,âŸ¨b,s,câŸ©âŸ©: Upon receiving a â€˜â€˜phase 2aâ€™â€™ request message from leader Î» with pvalue âŸ¨b,s,câŸ©, an acceptor makes the following transition. If the current ballot number equals~b, then the acceptor accepts âŸ¨b,s,câŸ©. The acceptor returns to Î» a â€˜â€˜phase 2bâ€™â€™ response message containing its current ballot number.</li>
</ul>

<h2 id="maintenance-of-acceptor-invariants">Maintenance of Acceptor Invariants</h2>
<p>The code enforces Invariants A1, A2, and A3. For checking the remaining two invariants, which involve multiple acceptors, we have to study what a leader does first, which is described in the following subsections.</p>

<p>An instance of the Synod protocol uses a fixed configuration C consisting of at least f+1 leaders and 2f+1 acceptors. For simplicity, assume configurations have no processes in common. Instances follow each other, creating a reconfigurable protocol. The 3D graph below shows the relation between ballots, slots, and configurations. A leader can use a single ballot to decide multiple slots, as in the case for slots 1 and 2. Multiple leaders might use multiple ballots during a single slot, as shown in slot 3. A configuration can have multiple ballots and can span multiple slots, but each slot and each ballot has only one configuration associated with it.</p>

<center>
<img src="../static/3dpaxos.png" height="300" />
</center>

<p>In the Synod protocol slot numbers and ballot numbers are
orthogonal concepts. One ballot can be used to decide on multiple
slots, like in slot 1 and slot 2. A slot may be considered by
multiple ballots, such as in slot 3. A configuration can span
multiple ballots and multiple slots, but they each belong to a
single configuration.</p>

<p>According to Invariant A4, there can be at most one proposed command per ballot number and slot number. The leader of a ballot is responsible for selecting a command for each slot, in such a way that selected commands cannot conflict with decisions on other ballots (Invariant A5).</p>

<h3 id="how-do-leaders-work">How do Leaders work?<a name="leaders"></a></h3>

<p>Leaders useÂ Commander andÂ Scout subprocesses to run the Synod protocol.</p>

<h2 id="leader-invariants">Leader Invariants</h2>

<p>As we shall see, the following invariants hold in the Synod protocol:</p>

<ul>
  <li>L1: For any ballotÂ bÂ and slotÂ s, at most one commandÂ cÂ is selected and at most one commander forÂ âŸ¨b,s,câŸ©Â is spawned.</li>
  <li>L2: Suppose that for eachÂ Î±Î±Â among a majority of acceptorsÂ âŸ¨b,s,câŸ© âˆˆ Î±.accepted. IfÂ bâ€²&gt;bÂ and a commander is spawned forÂ âŸ¨bâ€²,s,câ€²âŸ©, thenÂ c=câ€².</li>
</ul>

<p>Invariant L1 implies Invariant A4, because by L1 all acceptors that accept a pvalue for a particular ballot and slot number received the pvalue from the same commander. Similarly, Invariant L2 implies Invariant A5.</p>

<h2 id="commander">Commander</h2>

<p>A leader may work on multiple slots at the same time. For each such slot, the leader selects a command and spawns a new process that we call a commander. While we present it as a separate process, the commander is really just a thread running within the leader. The commander runs what is known asÂ phaseÂ 22Â of the Synod protocol.</p>

<p>Below you can find the pseudo-code for a Commander:</p>

<pre><code>
ğš™ğš›ğš˜ğšŒğšğšœğšœÂ Commander(Î»,acceptors,replicas,âŸ¨b,s,câŸ©)
Â Â ğšŸğšŠğš›Â waitfor:=acceptors;

Â Â âˆ€Î±âˆˆacceptors:send(Î±,âŸ¨p2a,self(),âŸ¨b,s,câŸ©âŸ©);
Â Â ğšğš˜ğš›Â ğšğšŸğšğš›
Â Â Â Â ğšœğš ğš’ğšğšŒğš‘Â receive()
Â Â Â Â Â Â ğšŒğšŠğšœğšÂ âŸ¨p2b,Î±,bâ€²âŸ©:
Â Â Â Â Â Â Â Â ğš’ğšÂ bâ€²=bÂ ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â waitfor:=waitfor-{Î±};
Â Â Â Â Â Â Â Â Â Â ğš’ğšÂ |waitfor|&lt;|acceptors|/2Â ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â Â Â âˆ€Ïâˆˆreplicas:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â send(Ï,âŸ¨decision,s,câŸ©;
Â Â Â Â Â Â Â Â Â Â Â Â exit();
Â Â Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â Â Â ğšğš•ğšœğš
Â Â Â Â Â Â Â Â Â Â send(Î»,âŸ¨preempted,bâ€²âŸ©);
Â Â Â Â Â Â Â Â Â Â exit();
Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â ğšğš—ğšÂ ğšŒğšŠğšœğš
Â Â Â Â ğšğš—ğšÂ ğšœğš ğš’ğšğšŒğš‘
Â Â ğšğš—ğšÂ ğšğš˜ğš›
ğšğš—ğšÂ ğš™ğš›ğš˜ğšŒğšğšœğšœ
</code></pre>

<p>A commander sends aÂ âŸ¨p2a,Î»,âŸ¨b,s,câŸ©âŸ© message to all acceptors, and waits for responses of the formÂ âŸ¨p2b,Î±,bâ€²âŸ©. In each such responseÂ bâ€²â‰¥bÂ will hold. There are two cases:</p>

<ul>
  <li>
    <p>If a commander receivesÂ âŸ¨p2b,Î±,bâŸ©from all acceptors in a majority of acceptors, then the commander learns that commandÂ ccÂ has been chosen for slotÂ s. In this case, the commander notifies all replicas and exits. To satisfy Invariant R1, we need to enforce that if a commander learns thatÂ ccÂ is chosen for slotÂ s, and another commander learns thatÂ câ€²Â is chosen for the same slotÂ s, thenÂ c=câ€². This is a consequence of Invariant A5: if a majority of acceptors acceptÂ âŸ¨b,s,câŸ©, then for any later ballotÂ bâ€²Â and the same slot numberÂ s, acceptors can only acceptÂ âŸ¨bâ€²,s,câŸ©. Thus if the commander ofÂ âŸ¨bâ€²,s,câ€²âŸ©Â learns thatÂ câ€²Â has been chosen forÂ s, it is guaranteed thatÂ c=câ€²Â and no inconsistency occurs, assumingâ€”of courseâ€”that Invariant L2 holds.</p>
  </li>
  <li>
    <p>If a commander receivesÂ âŸ¨p2b,Î±â€²,bâ€²âŸ©from some acceptorÂ Î±â€², withÂ bâ€²â‰ b, then it learns that a ballotÂ bâ€², which must be larger thanÂ bÂ as guaranteed by acceptors, is active. This means that ballotÂ bbÂ may no longer be able to make progress, as there may no longer exist a majority of acceptors that can acceptÂ âŸ¨b,s,câŸ©. In this case, the commander notifies its leader about the existence ofÂ bâ€², and exits.</p>
  </li>
</ul>

<p>Under the assumptions that at most a minority of acceptors can crash, that messages are delivered reliably, and that the commander does not crash, the commander will eventually do one or the other.</p>

<p>The leader must enforce Invariants L1 and L2. Because there is only one leader per ballot, Invariant L1 is trivial to enforce by the leader not spawning more than one commander per ballot number and slot number. To enforce Invariant L2, the leader runs what is often calledÂ phaseÂ 1Â of the Synod protocol or aÂ <strong>viewÂ change protocol</strong> for some ballot before spawning commanders for that ballot. The leader spawns aÂ scoutÂ thread to run the view change protocol for some ballotÂ bb. A leader starts at most one of these for any ballotÂ bb, and only for its own ballots.</p>

<h2 id="scout">Scout</h2>

<p>Below you can find the pseudo-code for a scout. The code is similar to that of a commander, except that it sends and receives phase 1 messages instead of phase 2 messages.</p>

<pre><code>
ğš™ğš›ğš˜ğšŒğšğšœğšœÂ Scout(Î»,acceptors,b)
Â Â ğšŸğšŠğš›Â waitfor:=acceptors,Â pvalues:=âˆ…;

Â Â âˆ€Î±âˆˆacceptors: send(Î±,âŸ¨p1a,self(),bâŸ©);
Â Â ğšğš˜ğš›Â ğšğšŸğšğš›
Â Â Â Â ğšœğš ğš’ğšğšŒğš‘Â receive()
Â Â Â Â Â Â ğšŒğšŠğšœğšÂ âŸ¨p1b,Î±,bâ€²,râŸ©:
Â Â Â Â Â Â Â Â ğš’ğšÂ bâ€²=bÂ ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â pvalues:=pvalues âˆª r;
Â Â Â Â Â Â Â Â Â Â waitfor:=waitfor-{Î±};
Â Â Â Â Â Â Â Â Â Â ğš’ğšÂ |waitfor|&lt;|acceptors|/2Â ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â Â Â send(Î»,âŸ¨adopted,b,pvaluesâŸ©);
Â Â Â Â Â Â Â Â Â Â Â Â exit();
Â Â Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â Â Â ğšğš•ğšœğš
Â Â Â Â Â Â Â Â Â Â send(Î»,âŸ¨preempted,bâ€²âŸ©);
Â Â Â Â Â Â Â Â Â Â exit();
Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â ğšğš—ğšÂ ğšŒğšŠğšœğš
Â Â Â Â ğšğš—ğšÂ ğšœğš ğš’ğšğšŒğš‘
Â Â ğšğš—ğšÂ ğšğš˜ğš›
ğšğš—ğšÂ ğš™ğš›ğš˜ğšŒğšğšœğšœ
</code></pre>

<p>A scout completes successfully when it has collectedÂ âŸ¨p1b,Î±,b,r<sub>Î±</sub>âŸ©Â messages from all acceptors in a majority, and returns a set of adopted messages to its leaderÂ Î». As we will see later, the leader usesÂ the union of all pvalues accepted by this majority of acceptors, in order to enforce Invariant L2.</p>

<h2 id="leader-state">Leader State</h2>

<p>LeaderÂ Î»Â maintains three state variables:</p>

<ul>
  <li>Î».ballot_num: a monotonically increasing ballot number, initiallyÂ (0,Î»).</li>
  <li>Î».active: a boolean flag, initiallyÂ ğšğšŠğš•ğšœğšfalse.</li>
  <li>Î».proposals: a map of slot numbers to proposed commands in the form of a set ofÂ âŸ¨slot number,commandâŸ©Â pairs, initially empty. At any time, there is at most one entry per slot number in the set.</li>
</ul>

<h2 id="leader-operational-description">Leader Operational Description</h2>

<p>Below you can find the pseudo-code for a Leader:</p>

<pre><code>
ğš™ğš›ğš˜ğšŒğšğšœğšœÂ Leader(acceptors,replicas)
Â Â ğšŸğšŠğš›Â ballot_num=(0,self()),active=ğšğšŠğš•ğšœğš,proposals=âˆ…;

Â Â spawn(Scout(self(),acceptors,ballot_num));
Â Â ğšğš˜ğš›Â ğšğšŸğšğš›
Â Â Â Â ğšœğš ğš’ğšğšŒğš‘Â receive()
Â Â Â Â Â Â ğšŒğšŠğšœğšÂ âŸ¨propose,s,câŸ©:
Â Â Â Â Â Â Â Â ğš’ğšÂ âˆ„câ€²:âŸ¨s,câ€²âŸ©âˆˆproposalsÂ ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â proposals:=proposalsâˆª{âŸ¨s,câŸ©};
Â Â Â Â Â Â Â Â Â Â ğš’ğšÂ activeÂ ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â Â Â spawn(Commander(self(),acceptors,replicas,âŸ¨ballot_num,s,câŸ©);
Â Â Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â ğšğš—ğšÂ ğšŒğšŠğšœe
Â Â Â Â Â Â ğšŒğšŠğšœğšÂ âŸ¨adopted, ballot_num, pvalsâŸ©:
Â Â Â Â Â Â Â Â proposals:=proposals âŠ² pmax(pvals);
Â Â Â Â Â Â Â Â âˆ€âŸ¨s,câŸ©âˆˆproposals:
Â Â Â Â Â Â Â Â Â Â spawn(Commander(self(),acceptors,replicas,âŸ¨ballot_num,s,câŸ©);
Â Â Â Â Â Â Â Â active:=ğšğš›ğšğš;
Â Â Â Â Â Â ğšğš—ğšÂ ğšŒğšŠğšœğš
Â Â Â Â Â Â ğšŒğšŠğšœğšÂ âŸ¨preempted,âŸ¨râ€²,Î»â€²âŸ©âŸ©:
Â Â Â Â Â Â Â Â ğš’ğšÂ (râ€²,Î»â€²)&gt;ballot_numÂ ğšğš‘ğšğš—
Â Â Â Â Â Â Â Â Â Â active:=ğšğšŠğš•ğšœğš;
Â Â Â Â Â Â Â Â Â Â ballot_num:=(râ€²+1, self());
Â Â Â Â Â Â Â Â Â Â spawn(Scout(self(),acceptors,ballot_num));
Â Â Â Â Â Â Â Â ğšğš—ğšÂ ğš’ğš
Â Â Â Â Â Â ğšğš—ğšÂ ğšŒğšŠğšœğš
Â Â Â Â ğšğš—ğšÂ ğšœğš ğš’ğšğšŒğš‘
Â Â ğšğš—ğšÂ ğšğš˜ğš›
ğšğš—ğšÂ ğš™ğš›ğš˜ğšŒğšğšœğšœ
</code></pre>

<p>The leader starts by spawning a scout for its initial ballot number, and then enters into a loop awaiting messages. There are three types of messages that cause transitions:</p>

<ul>
  <li>âŸ¨propose,s,câŸ©: A replica proposes commandÂ cÂ for slot numberÂ s.</li>
  <li>âŸ¨adopted,ballot_num,pvalsâŸ©: Sent by a scout, this message signifies that the current ballot numberÂ ballot_numÂ has been adopted by a majority of acceptors. If anÂ adoptedÂ message arrives for an old ballot number, it is ignored. The setÂ pvalsÂ contains all pvalues accepted by these acceptors prior toÂ ballot_num.</li>
  <li>âŸ¨preempted,âŸ¨râ€²,Î»â€²âŸ©âŸ©: Sent by either a scout or a commander, it means that some acceptor has adoptedÂ âŸ¨râ€²,Î»â€²âŸ©. IfÂ âŸ¨râ€²,Î»â€²âŸ©&gt;ballot_num, it may no longer be possible to use ballotÂ ballot_numÂ to choose a command.</li>
</ul>

<p>A leader goes betweenÂ passiveÂ andÂ activeÂ modes. When passive, the leader is waiting for anÂ âŸ¨adopted,ballot_num,pvalsâŸ©Â message from the last scout that it spawned. When this message arrives, the leader becomes active and spawns commanders for each of the slots for which it has a proposed command, but must select commands that satisfy Invariant L2. We will now consider how the leader goes about this.</p>

<p>When active, the leader knows that a majority of acceptors, sayÂ A, have adoptedÂ ballot_numÂ and thus no longer accept pvalues for ballot numbers less thanÂ ballot_num, because of Invariants A1 and A2. In addition, it has all pvalues accepted by the acceptors inÂ AÂ prior toÂ ballot_num. The leader uses these pvalues to update its own proposals variable. There are two cases to consider:</p>

<ul>
  <li>If, for some slotÂ s, there is no pvalue inÂ pvals, then, prior toÂ ballot_num, it is not possible that any pvalue has been chosen or will be chosen for slotÂ s. After all, suppose that some pvalueÂ âŸ¨b,s,câŸ©Â were chosen, withÂ b&lt;ballot_num. This would require a majority of acceptorsÂ Aâ€²Â to acceptÂ âŸ¨b,s,câŸ©, but we have responses from a majorityÂ AÂ that have adoptedÂ ballot_numÂ and have not accepted, nor can accept, pvalues with a ballot number smaller thanÂ ballot_num, by Invariants A1 and A2. Because bothÂ AÂ andÂ Aâ€²Â are majorities,Â Aâˆ©Aâ€²Â is non-emptyâ€”some acceptor in the intersection must have violated Invariant A1, A2, or A3, which we assume cannot happen. Because no pvalue has been or will be chosen for slotÂ sÂ prior toÂ ballot_num, the leader can propose any command for that slot without causing a conflict on an earlier ballot, thus enforcing Invariant L2.</li>
  <li>Otherwise, letÂ âŸ¨b,s,câŸ© be the pvalue with the maximum ballot number for slotÂ s. Because of Invariant A4, this pvalue is uniqueâ€”there cannot be two different commands for the same ballot number and slot number. Also note thatÂ b&lt;ballot_numb&lt;ballot_num, because acceptors only report pvalues they accepted before adoptingÂ ballot_num. Like the leader ofÂ ballot_num, the leader ofÂ bbÂ must have pickedÂ ccÂ carefully to ensure that Invariant L2 holds, and thus if a pvalue is chosen before or atÂ bb, the command it contains must beÂ cc. Since all acceptors inÂ AÂ have adoptedÂ ballot_num, no pvalues betweenÂ bbÂ andÂ ballot_num can be chosen, by Invariants A1 and A2. Thus, by usingÂ ccÂ as a command,Â Î»Â enforces Invariant L2.</li>
</ul>

<p>This inductive argument is the crux for the correctness of the Synod protocol. It demonstrates that Invariant L2 holds, which in turn implies Invariant A5, which in turn implies Invariant R1 that ensures that all replicas apply the same operations in the same order.</p>

<p>Back to the code, after the leader receivesÂ âŸ¨adopted,ballot_num,pvalsâŸ©, it determines for each slot the command corresponding to the maximum ballot number inÂ pvalsÂ by invoking the functionÂ pmax. Formally, the functionÂ pmax(pvals)Â is defined as follows:</p>

<pre><code>pmax(pvals)â‰¡{âŸ¨s,câŸ©Â |Â âˆƒb:âŸ¨b,s,câŸ©âˆˆpvalsÂ âˆ§Â âˆ€bâ€²,câ€²:âŸ¨bâ€²,s,câ€²âŸ©âˆˆpvalsâ‡’bâ€²â‰¤b}
</code></pre>

<p>The update operatorÂ âŠ²Â applies to two sets of proposals.Â xâŠ²yÂ returns the elements ofÂ yÂ as well as the elements ofÂ xÂ that are not inÂ y. Formally:</p>

<pre><code>xâŠ²yâ‰¡{âŸ¨s,câŸ©Â |Â âŸ¨s,câŸ©âˆˆyÂ âˆ¨Â (âŸ¨s,câŸ©âˆˆxÂ âˆ§âˆ„câ€²:âŸ¨s,câ€²âŸ©âˆˆy)}</code></pre>

<p>Thus the lineÂ proposals:=proposalsâŠ²pmax(pvals);Â updates the set of proposals, replacing for each slot number the command corresponding to the maximum pvalue inÂ pvals, if any. Now the leader can start commanders for each slot while satisfying Invariant L2.</p>

<p>If a new proposal arrives while the leader is active, the leader checks to see if it already has a proposal for the same slotÂ ((and has thus spawned a commander for that slot))Â in its setÂ proposals. If not, the new proposal will satisfy Invariant L2, and thus the leader adds the proposal toÂ proposalsÂ and spawns a commander.</p>

<p>If either a scout or a commander detects that an acceptor has adopted a ballot numberÂ b, withÂ b&gt;ballot_num, then it sends the leader aÂ ğš™ğš›ğšğšğš–ğš™ğšğšğšÂ message. The leader becomes passive and spawns a new scout with a ballot number that is higher thanÂ b.</p>

<p>Below is an example of a leaderÂ Î»Â spawning a scout to become active, and a clientÂ ÎºÂ sending a request to two replicasÂ Ï1Â andÂ Ï2, which in turn send proposals toÂ Î».</p>

<center>
<img src="../static/paxos.png" height="400" />
</center>
<p><a name="when"></a></p>
<h2 id="when-does-paxos-work-what-about-the-impossibility-of-consensus-result">When does Paxos work? What about the impossibility of consensus result?</h2>

<p>It would clearly be desirable that, if a client broadcasts a new command to all replicas, that it eventually receives at least one response. This is an example of a liveness property. It requires that if one or more commands have been proposed for a particular slot, that some command is eventually decided for that slot. Unfortunately, the Synod protocol as described does not guarantee this, even in the absence of any failure whatsoever. In fact, failures tend to be good for liveness. If all leaders but one fail, Paxos is guaranteed to terminate.</p>

<p><img src="../static/pingpong.png" /></p>

<p>Consider the following scenario shown above, with two leaders with identifiers Î» and Î»â€² such that Î»&lt;Î»â€². Both start at the same time, respectively proposing commands c and câ€² for slot number 1. Suppose there are three acceptors, Î±1, Î±2, and Î±3. In ballot âŸ¨0,Î»âŸ©, leader Î» is successful in getting Î±1 and Î±2 to adopt the ballot, and Î±1 to accept pvalue âŸ¨âŸ¨0,Î»âŸ©,1,câŸ©.</p>

<p>Now leader Î»â€² gets Î±2 and Î±3 to adopt ballot âŸ¨0,Î»â€²âŸ©, which has a higher ballot number than ballot âŸ¨0,Î»âŸ© because Î»&lt;Î»â€². Note that neither Î±2 or Î±3 accepted any pvalues, so leader Î»â€² is free to select any proposal. Leader Î»â€² then gets Î±3 to accept âŸ¨âŸ¨0,Î»â€²âŸ©,1,câ€²âŸ©.</p>

<p>At this point, acceptors Î±2 and Î±3 are unable to accept âŸ¨âŸ¨0,Î»âŸ©,1,câŸ© and thus leader Î» is unable to get a majority of acceptors to accept âŸ¨âŸ¨0,Î»âŸ©,1,câŸ©. Trying again with a higher ballot, leader Î» gets Î±1 and Î±2 to adopt âŸ¨1,Î»âŸ©. The maximum pvalue accepted by Î±1 and Î±2 is âŸ¨âŸ¨0,Î»âŸ©,1,câŸ©, and thus Î» must propose c. Suppose Î» gets Î±1 to accept âŸ¨âŸ¨1,Î»âŸ©,1,câŸ©. Because acceptors Î±1 and Î±2 adopted âŸ¨1,Î»âŸ©, they are unable to accept âŸ¨âŸ¨0,Î»â€²âŸ©,1,câ€²âŸ©. Trying to make progress, leader Î»â€² gets Î±2 and Î±3 to adopt âŸ¨1,Î»â€²âŸ©, and gets Î±3 to accept âŸ¨âŸ¨1,Î»â€²âŸ©,1,câ€²âŸ©.</p>

<p>This ping-pong scenario can be continued indefinitely, with no ballot ever succeeding in choosing a pvalue. This is true even if c=câ€², that is, the leaders propose the same command. The well-known â€˜â€˜FLP impossibility resultâ€™â€™ demonstrates that in an asynchronous environment that admits crash failures, no consensus protocol can guarantee termination, and the Synod protocol is no exception. The argument does not apply directly if transitions have non-deterministic actionsâ€”for example changing state in a randomized manner. However, it can be demonstrated that such protocols cannot guarantee a decision either.</p>

<p>If we could somehow guarantee that some leader would be able to work long enough to get a majority of acceptors to adopt a high ballot and also accept a pvalue, then Paxos would be guaranteed to choose a proposed command. A possible approach could be as follows: when a leader Î» discovers, through a ğš™ğš›ğšğšğš–ğš™ğšğšğš message, that there is a higher ballot with leader Î»â€² active, rather than starting a new scout with an even higher ballot number, Î» starts monitoring Î»â€² by pinging it on a regular basis. As long as Î»â€² responds timely to pings, Î» waits patiently. Only if Î»â€² stops responding will Î» select a higher ballot number and start a scout.</p>

<p>This concept is called failure detection, and theoreticians have been interested in the weakest properties failure detection should have in order to support a consensus algorithm that is guaranteed to terminate. In a purely asynchronous environment, it is impossible to determine through pinging or any other method whether a particular leader has crashed or is simply slow. However, under fairly weak assumptions about timing, we can design a version of Paxos that is guaranteed to choose a proposal. In particular, we will assume that both the following are bounded:</p>

<p>the clock drift of a process, that is, the rate of its clock is within some factor of the rate of real-time;
the time between when a non-faulty process initiates sending a message, and the message having been received and handled by a non-faulty destination process.
We do not need to assume that we know what those bounds areâ€”only that such bounds exist. From a practical point of view, this seems entirely reasonable. Modern clocks progress certainly within a factor of 2 of real-time. A message between two non-faulty processes is likely delivered and processed within, say, a year. Even if the network was partitioned at the time the sender started sending the message, by the time a year has expired the message is highly likely to have been delivered and processed.</p>

<p>These assumptions can be exploited as follows: we use a scheme similar to the one described above, based on pinging and timeouts, but the value of the timeout interval depends on the ballot number: the higher the competing ballot number, the longer a leader waits before trying to preempt it with a higher ballot number. Eventually the timeout at each of the leaders becomes so high that some correct leader will always be able to get its proposals chosen.</p>

<p>For good performance, one would like the timeout period to be long enough so that a leader can be successful, but short enough so that the ballots of a faulty leader are preempted quickly. This can be achieved with a TCP-like AIMD (Additive Increase, Multiplicative Decrease) approach for choosing timeouts. The leader associates an initial timeout with each ballot. If a ballot gets preempted, the next ballot uses a timeout that is multiplied by some small factor larger than one. With each chosen proposal, this initial timeout is decreased linearly. Eventually the timeout will become too short, and the ballot will be replaced with another even if its leader is non-faulty.</p>

<p>Liveness can be further improved by keeping state on disk. The Paxos protocol can tolerate a minority of its acceptors failing, and all but one of its replicas and leaders failing. If more than that fail, consistency is still guaranteed, but liveness will be violated. A process that suffers from a power failure but can recover from disk is not theoretically considered crashedâ€”it is simply slow for a while. Only a process that suffers a permanent disk failure would be considered crashed.</p>

<p>For completeness, we note that for liveness we also assumed reliable communication. This assumption can be weakened by using a fair links assumption: if a correct process repeatedly sends a message to another correct process, at least one copy is eventually delivered. Reliable transmission of a message can then be implemented by periodic retransmission until an ack is received. In order to prevent overload on the network, the time intervals between retransmissions can grow until the load imposed on the network is negligible. The fair links assumption can be weakened further, but such a discussion is outside the scope of this paper.</p>

<p>As an example of how liveness is achieved, a correct client retransmits its request to replicas until it has received a response. Because there are at least  f+1 replicas, at least one of those replicas will not fail and will assign a slot to the request and send a proposal to the  f+1 or more leaders. Thus at least one correct leader will try to get a command decided for that slot. Should a competing command get decided, the replica will reassign the request to a new slot and retry. While this may lead to starvation, in the absence of new requests, any outstanding request will eventually get decided in at least one slot.</p>
:ET